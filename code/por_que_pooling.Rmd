---
title: "¿Por qué Pooling?"
author: "David Jiménez González"
date: "5/13/2020"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

```

## Introducción

Esta idea nació como una inquietud a partir un articulo sobre el trabajo de
Dina Berenbaum disponible en el medio
[Times of Israel](https://www.timesofisrael.com/to-ease-global-virus-test-bottleneck-israeli-scientists-suggest-pooling-samples/),
donde se indica la posibilidad de emplear pruebas no sólo a indivíduos con 
potencial de estar infectados, sino a grupos de ellos. Lo más intrigante de
este efoque radica en lo sencillo del concepto. Con esto en mente se trata 
de evaluar las propiedades numéricas de este tipo de tests en una población
infectada con COVID19 y realizar una evaluación preliminar de las potenciales
ventajas que este procedimiento podría presentar.

Para ello se construyó una simulación muy sencilla donde se trata de emular las 
características de una población con diferentes niveles de contagio. Se 
aprovecha esta simulación para probar diferentes formas de organizar las pruebas
y el tamaño de las mismas para así de alguna forma "optimizar" el uso de estas,
que equivale conceptualmente a un aumento en la capacidad de evaluación.

## Construcción de la población contagiada

Para la construcción de la población se definen $N$ individuos que pertenecen a
familias, que residen en edificios, que están construidos en vencindarios. Se 
define de forma arbitraria que el número de invididuos por familia es $5$,
el número de familas por edificio es $2$, el número de de edificios por 
vencindario es de $10$. Además, se define una tasa inicial de estos indivíduos
que están contagiados $p_{0i}$ que son diseminados aleatoriamente en la 
población.

Es importante notar que esta población tiene las características de una fase
inicial de la epidemia donde los casos se distribuyen al azar, queremos que,
al igual que en una población normal los casos de alguna forma se agrupen cerca
de los grupos sociales donde interactuan. Para ello construimos una función de 
probabilidad de contagio.

Esta función emplea el número de casos contagiados en los grupos a los que 
pertenece cada indivíduo y además agrega un componente de aleatoriedad. Por 
facilidad e interpletabilidad se emplea una función logística para calcular
dicha probabilidad.

$$ p_{ij} = \frac{1}{1+e^{-l_j}} $$
$$ l_{ij} = \alpha_{fam}*n_{fam_{ij}} + \alpha_{edi}*n_{edi_{ij}}+\alpha_{vec_{ij}}*n_{vec} + \alpha_{t}*n_{t_{i}} $$
Donde se emplea para el paso de tiempo que se está analizando $t_i$ 
el número de contagiados $n_x$ de cada uno de los grupos a los
que pertenece el individuo $j$, el todal de contagiados $n_t$ y ciertos pesos 
$\alpha_x$ para así determinar la probabilidad de que el el individuo $j$ esté
contagiado en el siguiente paso de tiempo $t_{i+1}$.

```{r funcion_probabilidad_contagio, cache=FALSE, echo = FALSE}

createInfPFun<- function(modelCoefFact = 0.5,
                         modelCoef=list(fam = log(2),
                                        buil = log(1.5), 
                                        neib = log(1.25),
                                        p0 = log(10))){
      
      InfProb <- function(fam, buil, nei, p0){
            mapply(
                  FUN = function(famX,builX,neiX, p0X){
                        
                        l<- modelCoefFact*(famX * modelCoef$fam + 
                                   builX * modelCoef$buil + 
                                   neiX * modelCoef$neib + 
                                   p0X * modelCoef$p0 )
                        
                        
                        p<- 1/(1+exp(-l))
                        
                  },
                  fam,buil,nei,p0
            )
            
      }
      
      return(InfProb)
      
}

```

```{r funcion_crear_poblacion, cache=FALSE, echo = FALSE}

createSus <- function(N = 10000, pI = 0.005){
      
      nIni<- max(round(N*pI),1)
      nSus <- N
      inf <- sample(1:nSus, nIni)
      nFam <- ceiling(nSus/5)
      nBuil <- ceiling(nFam/2)
      nNei <- ceiling(nFam/10)
      
      nei <- tibble(nei = 1:nNei,
                    lng = sample(1:nNei,nNei), 
                    lat = sample(1:nNei,nNei))
      
      buil <- tibble(buil = 1:nBuil,
                     nei = sample(1:nNei, size = nBuil , replace = T))%>%
            left_join(nei,by = "nei")
      
      fam <- tibble(fam = 1:nFam,
                    buil = sample(1:nBuil, size = nFam , replace = T))%>%
            left_join(buil, by ="buil")
      
      sus <- tibble(sus = 1:nSus,
                    fam = sample(1:nFam, size = nSus, replace = T),
                    inf = sus %in% inf)%>%
            left_join(fam, by ="fam")%>%
            group_by(fam)%>%
            mutate(infFam = sum(inf))%>%
            ungroup()%>%
            group_by(buil)%>%
            mutate(infBuil =  sum(inf))%>%
            ungroup()%>%
            group_by(nei)%>%
            mutate(infNei =  sum(inf))%>%
            ungroup()%>%
            mutate(infP = InfProb (infFam,infBuil,infNei,nIni/nSus)) 
            
      return(sus)
}

```

```{r crear_poblacion_ejemplo, cache=FALSE}

set.seed(5)

#Se crea la función de probabilidad en el ambiente
InfProb<-createInfPFun()

#Se crea la población inicial y se calcula para cada individuo pj
sus<-createSus(N = 1000, pI = 0.005)

#La tabla de la primera iteración podría verse así
head(sus, 5)

```

Para visualizar de alguna forma los vecindarios le asignamos de
forma aleatoria a los vecindarios una longitud y latitud.

```{r presentar_poblacion, cache=FALSE, echo = F }

set.seed(0)
sus%>%
    ggplot()+
    geom_jitter(aes(lng,lat,col = inf, alpha= inf), width = 1, height = 1,)+
    scale_color_manual(values= c("grey50","red"))+
    scale_alpha_manual(values =c(0.3,0.80))+
    theme_minimal()

```

Para obtener los casos contagiados en el tiempo $t_{i+1}$ se toma el valor de 
probabilidad para cada individuo y se determina si el mismo está por encima de
un umbral definido como $u_{ij} = u_0 + U(-0.05, 0.05)$ donde $u_0$ es un valor
base y a este se le agrega el valor de una distribución uniforme. Si en efecto
se encuentra por encima del umbral o bien ya estaba contagiado la condición del
indivíduo hasta la última interación será como contagiado. Nótese que en este
modelo no se tienen casos recuperados ya que la finalidad es luego, para 
poblaciones con diferentes niveles de contagio evaluar el uso de la metodología
anteriormente mencionada.

```{r funcion_siguiente_paso, cache=FALSE, echo = FALSE}

nextIter<-function(sus, threshold, p0){
   
      sus<-sus%>%
            mutate(infP = InfProb (infFam,infBuil,infNei,p0),
                   inf = inf | infP > (threshold+runif(1,-0.05,+0.05)),
            ) %>%
            group_by(fam)%>%
            mutate(infFam = sum(inf))%>%
            ungroup()%>%
            group_by(buil)%>%
            mutate(infBuil =  sum(inf))%>%
            ungroup()%>%
            group_by(nei)%>%
            mutate(infNei =  sum(inf))%>%
            ungroup()
      
      return(sus)
      
}

```

Luego de unas cuantas interaciones la población aumenta su número de casos
infectados. 

```{r actualizar_poblacion, cache=FALSE, echo = T}


p0<- sum(sus$inf) / nrow(sus)
sus<- nextIter(sus, threshold = 0.70, p0 = p0)
p0<- sum(sus$inf) / nrow(sus)
sus<- nextIter(sus, threshold = 0.70, p0 = p0)
p0<- sum(sus$inf) / nrow(sus)
sus<- nextIter(sus, threshold = 0.70, p0 = p0)
p0<- sum(sus$inf) / nrow(sus)
sus<- nextIter(sus, threshold = 0.70, p0 = p0)
p0<- sum(sus$inf) / nrow(sus)
p0

```


```{r presentar_poblacion_mod, cache=FALSE, echo = F, }

set.seed(0)
sus%>%
    ggplot()+
    geom_jitter(aes(lng,lat,col = inf, alpha= inf), width = 1, height = 1,)+
    scale_color_manual(values= c("grey50","red"))+
    scale_alpha_manual(values =c(0.3,0.80))+
    theme_minimal()

```


